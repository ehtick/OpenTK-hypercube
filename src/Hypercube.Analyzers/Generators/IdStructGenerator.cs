using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Hypercube.Analyzers.Generators;

[Generator]
public sealed class IdStructGenerator : ISourceGenerator
{
    private const string AttributeName = "IdStructAttribute";
    
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver) 
            return;

        foreach (var structDecl in receiver.CandidateStructs)
        {
            var model = context.Compilation.GetSemanticModel(structDecl.SyntaxTree);
            var symbol = ModelExtensions.GetDeclaredSymbol(model, structDecl);
            if (symbol is null)
                continue;
            
            var attribute = symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == AttributeName);
            if (attribute is null)
                continue;

            var underlyingType = attribute.ConstructorArguments[0].Value as INamedTypeSymbol;
            var nullCast = attribute.ConstructorArguments.Length > 1 && attribute.ConstructorArguments[1].Value is true;
            
            var typeName = underlyingType?.ToDisplayString() ?? "int";
            
            var namespaceName = symbol.ContainingNamespace.ToDisplayString();
            var structName = symbol.Name;

            var source = $$"""
                           // <auto-generated/>
                           #nullable enable

                           using System;
                           using System.Diagnostics;
                           using System.Runtime.CompilerServices;
                           using System.Runtime.InteropServices;

                           namespace {{namespaceName}}
                           {
                               [DebuggerDisplay("{Value}")]
                               [StructLayout(LayoutKind.Sequential)]
                               public readonly partial struct {{structName}} : IEquatable<{{structName}}>
                               {
                                   public readonly {{typeName}} Value;

                                   public {{structName}}({{typeName}} value) => Value = value;
                                   
                                   {{GenerateToStringMethod(typeName)}}

                                   [MethodImpl(MethodImplOptions.AggressiveInlining)]
                                   public bool Equals({{structName}} other) => Value == other.Value;

                                   [MethodImpl(MethodImplOptions.AggressiveInlining)]
                                   public override bool Equals(object? obj) => obj is {{structName}} id && Equals(id);

                                   [MethodImpl(MethodImplOptions.AggressiveInlining)]
                                   {{GenerateHashCodeMethod(typeName)}}
                                   
                                   [MethodImpl(MethodImplOptions.AggressiveInlining)]
                                   public static bool operator ==({{structName}} a, {{structName}} b) => a.Value == b.Value;

                                   [MethodImpl(MethodImplOptions.AggressiveInlining)]
                                   public static bool operator !=({{structName}} a, {{structName}} b) => a.Value != b.Value;
                               
                                   {{GenerateImplicitOperators(structName, typeName, nullCast)}}
                               }
                           }
                           """;

            context.AddSource($"{structName}_IdBindings.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }
    
    private static bool IsNullable(string typeName)
    {
        return typeName.EndsWith("?");
    }

    private static string GenerateToStringMethod(string typeName)
    {
        return IsNullable(typeName)
            ? "public override string ToString() => Value?.ToString() ?? string.Empty;"
            : "public override string ToString() => Value.ToString();";
    }

    private static string GenerateHashCodeMethod(string typeName)
    {
        return IsNullable(typeName)
            ? "public override int GetHashCode() => Value?.GetHashCode() ?? 0;"
            : "public override int GetHashCode() => Value.GetHashCode();";
    }
    
    private static string GenerateImplicitOperators(string structName, string typeName, bool nullCast)
    {
        if (!IsNullable(typeName) || nullCast)
            return $"""
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                            public static implicit operator {typeName}({structName} id) => id.Value;

                            [MethodImpl(MethodImplOptions.AggressiveInlining)]
                            public static implicit operator {structName}({typeName} value) => new(value);
                    """;

        var valueTypeName = typeName.TrimEnd('?');
        return $"""
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static implicit operator {valueTypeName}({structName} id) => id.Value ?? default;

                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static implicit operator {structName}({valueTypeName} value) => new(value);
                """;

    }
    
    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<StructDeclarationSyntax> CandidateStructs { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is StructDeclarationSyntax structDecl && structDecl.Modifiers.Any(SyntaxKind.PartialKeyword))
            {
                CandidateStructs.Add(structDecl);
            }
        }
    }
}